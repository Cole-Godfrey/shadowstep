<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Shadowstep</title>
<style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    canvas{display:block;touch-action:none}
</style>
<canvas id="c"></canvas>
<script>
    // ===== Canvas bootstrap =====
    const C = document.getElementById('c');
    const ctx = C.getContext('2d', { alpha:false });
    const T = 8; // tile size (CSS px)

    function fit() {
        const dpr = Math.max(1, Math.min(3, devicePixelRatio||1));
        const w = Math.floor(innerWidth  * dpr);
        const h = Math.floor(innerHeight * dpr);
        if (C.width !== w || C.height !== h) {
            C.width = w; C.height = h;
            C.style.width  = innerWidth + 'px';
            C.style.height = innerHeight + 'px';
            ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
        }
        makeStars();        // rebuild starfield to fit new size (deterministic)
        world = genWorld(); // rebuild rooftops
        spawnCat();         // put the cat on a safe spot
    }
    addEventListener('resize', fit, { passive:true });

    // ===== Utilities =====
    const A=Math, Sn=A.sin, Fl=A.floor, Mn=A.min, Mx=A.max, Ab=A.abs, Cs=A.cos, At=A.atan2;
    // New level each refresh; same level across resizes.
    // Optional: pass ?seed=1234 in the URL to reproduce a layout.
    const LEVEL_SEED = (() => {
        const q = new URLSearchParams(location.search).get('seed');
        if (q) return (parseInt(q,10)|0) || 1;
        try { return (crypto.getRandomValues(new Uint32Array(1))[0] | 0) || 1; }
        catch { return (Date.now() ^ ((Math.random()*0xFFFFFFFF)|0)) | 0; }
    })();

    const clamp=(x,a,b)=>x<a?a:x>b?b:x;

    // Sprite-to-physics alignment
    const BODY_W = 26, BODY_H = 36; // physics hitbox (≈ sprite’s body, not full 50x50)
    const SPRITE_FOOT_OFFSET = 18
    const SPRITE_X_OFFSET = 0;
    const SPRITE_Y_OFFSET = 0;
    const DEBUG_SPRITE_ALIGN = false; // turn on if you need to re-align

    // Seeded PRNG: xorshift32
    let S=0;
    const seed=(n)=>{ S=(n|0)||1; }; // never 0
    const R=()=>{ S^=S<<13; S^=S>>>17; S^=S<<5; return (S>>>0)/4294967296; };
    const rand=(a=1,b=0)=>b+(a-b)*R();

    // ===== Stars (deterministic) =====
    let stars=[];
    function makeStars(){
        seed(LEVEL_SEED);
        const N = 180;
        stars = Array.from({length:N}, ()=>({
            x: rand(0, innerWidth),
            y: rand(0, innerHeight),
            s: rand(2.2, 4.0),
            p: rand(0, 6.283)
        }));
    }

    // ===== World / Rooftops =====
    // tiles: 0=air, 1=top, 2=solid
    let world=null;

    function genWorld(){
        seed(LEVEL_SEED);
        console.log('level seed:', LEVEL_SEED);
        const w = Math.ceil(innerWidth / T) + 32;
        const h = Math.max(28, Math.ceil(innerHeight / T));
        const tiles  = new Uint8Array(w*h);
        const cursed = new Uint16Array(w*h);
        let emitters = [];
        const charms = [];

        // === Skyline made of building segments + street gaps ===
        let x = 0;
        let roofY = Fl(h * 0.62);                 // starting roof height
        const roofMin = 6, roofMax = h - 8;       // clamp so we don't hit top/bottom

        while (x < w){
            // ---- BUILDING segment ----
            const bW = Fl(rand(22, 10));            // width ~10..22 tiles
            // cap the inter-building step so it stays jumpable
            const MAX_STEP_TILES = 6; // try 6; 5 = easier, 7 = harder
            const delta = ((R() * (2*MAX_STEP_TILES + 1)) | 0) - MAX_STEP_TILES; // -MAX..+MAX
            roofY = clamp(roofY + delta, roofMin, roofMax);


            for (let i=0; i<bW && x<w; i++, x++){
                // gentle parapet jitter every few tiles to create small steps
                if (i && !(i % 3)){
                    roofY = clamp(roofY + (Fl(rand(3,0)) - 1), roofMin, roofMax); // -1..+1
                }
                tiles[x + roofY*w] = 1;               // roof cap
                for (let yy=roofY+1; yy<h; yy++) tiles[x + yy*w] = 2; // solid below
            }

            // ---- STREET gap ---- (air columns)
            const gW = Fl(rand(6, 2));              // width ~2..6 tiles
            for (let i=0; i<gW && x<w; i++, x++) { /* leave air */ }
        }

        // Emitters after skyline is built
        emitters = buildEmitters(tiles, w, h);

        return { w, h, tiles, cursed, emitters, charms, levelSeed: LEVEL_SEED };
    }


    // Build emitters along vertical walls:
    // pick tiles where tiles[x,y]==2 (solid), tiles[x,y-1]==2 (not the top),
    // and either tiles[x+1,y]==0 (right face) or tiles[x-1,y]==0 (left face).
    function buildEmitters(tiles, w, h){
        const visMaxX = Math.min(w-2, Math.ceil(innerWidth / T) + 1);

        // Roof top per column (y index of first non-air); h = street gap
        const top = new Int16Array(visMaxX+1);
        for (let x=0; x<=visMaxX; x++){
            let y=0, found=false;
            for (; y<h; y++){ if (tiles[x + y*w]) { found=true; break; } }
            top[x] = found ? y : h;
        }

        // helper: find next non-gap building column in a direction (±1)
        function nextBuilding(fromX, dir){
            let x = fromX + dir;
            while (x>=0 && x<=visMaxX){
                if (top[x] < h) return x;
                x += dir;
            }
            return -1;
        }

        const MIN_STEP = 2;        // require at least 2 tiles height diff
        const ORG_OFF  = 0.35;     // origin offset below tall roof (tiles)
        const TGT_OFF  = 0.35;     // aim offset above short roof (tiles)

        const cand = [];

        // For each building column, compare to the *next* building on each side (skip gaps)
        for (let x=0; x<=visMaxX; x++){
            if (top[x] === h) continue; // skip gaps themselves

            // check right neighbor across any gap
            const xr = nextBuilding(x, +1);
            if (xr !== -1){
                const tallY = top[x], shortY = top[xr];
                if (tallY + MIN_STEP <= shortY){
                    cand.push({ wallX:x, dir:+1, tallY, shortY, tgtX:xr });
                }
            }

            // check left neighbor across any gap
            const xl = nextBuilding(x, -1);
            if (xl !== -1){
                const tallY = top[x], shortY = top[xl];
                if (tallY + MIN_STEP <= shortY){
                    cand.push({ wallX:x, dir:-1, tallY, shortY, tgtX:xl });
                }
            }
        }

        // sample a handful across the width
        const target = Math.max(3, (visMaxX/18)|0); // slightly denser
        const chosen = [];
        while (chosen.length < target && cand.length){
            const k = (R()*cand.length)|0;
            const c = cand.splice(k,1)[0];

            // origin on face of the TALLER building, just below its roof cap
            const px = (c.dir>0 ? (c.wallX+1) : c.wallX) * T;
            const py = (c.tallY + ORG_OFF) * T;

            // aim to the SHORTER neighbor’s roof center, a hair above its cap
            const tx = (c.tgtX + 0.5) * T;
            const ty = (c.shortY - TGT_OFF) * T;

            const center = Math.atan2(ty - py, tx - px);   // guaranteed “downward” across the step
            const dist   = Math.hypot(tx - px, ty - py);

            chosen.push({
                x:px, y:py,
                center,
                amp:    rand(0.16, 0.30),   // side-to-side scan amplitude (radians)
                omega:  rand(0.6, 1.0),     // scan speed
                spread: rand(0.85, 1.25),   // wider cone for visibility
                len:    Math.min(420, dist + 6*T), // longer beams
                flicker:rand(1.6, 3.0),
                phase:  rand(0, 6.283)
            });
        }

        console.log('emitters (taller→next-shorter across gaps):', chosen.length);
        return chosen;
    }






    // ===== Input =====
    const keys = {L:0,R:0,J:0,M:0};
    addEventListener('keydown', e=>{
        const c=e.code;
        if (c==='ArrowLeft' || c==='KeyA'){ keys.L=1; e.preventDefault(); }
        if (c==='ArrowRight'|| c==='KeyD'){ keys.R=1; e.preventDefault(); }
        if (c==='ArrowUp' || c==='KeyZ' || c==='Space'){ keys.J=1; e.preventDefault(); jumpBuffer = JUMP_BUF; }
        if (c==='KeyX'){ keys.M=1; e.preventDefault(); }
    });
    addEventListener('keyup', e=>{
        const c=e.code;
        if (c==='ArrowLeft' || c==='KeyA'){ keys.L=0; }
        if (c==='ArrowRight'|| c==='KeyD'){ keys.R=0; }
        if (c==='ArrowUp' || c==='KeyZ' || c==='Space'){ keys.J=0; }
        if (c==='KeyX'){ keys.M=0; }
    });

    // ===== Player (cat) physics =====
    const cat = {x:0,y:0,w:BODY_W,h:BODY_H,vx:0,vy:0,onGround:false,dir:1};
    // Tunables (pixels / second units)
    const GRAV=1200, MAX_FALL=700, JUMP_V=380, ACC=2000, MAX_VX=200;
    const COYOTE=0.10, JUMP_BUF=0.12;
    let coyote=0, jumpBuffer=0;

    // Spawn near the left on top of the skyline
    function spawnCat(){
        const tx = 6;
        let ty = 0;
        for (; ty<world.h; ty++) if (world.tiles[tx + ty*world.w]) break;
        cat.x = tx*T + (T-cat.w)/2;
        cat.y = ty*T - cat.h - 1;
        cat.vx = cat.vy = 0;
        cat.onGround = false; coyote=0; jumpBuffer=0;
        cat.dir = 1;
        // play stretch on spawn
        startAnim('Stretching', 0.55); // ~0.55s, then auto-return to idle
    }

    // Tile helpers
    const TI = (tx,ty)=> (tx<0||ty<0||tx>=world.w||ty>=world.h) ? 2 : world.tiles[tx + ty*world.w];
    const solid = (tx,ty)=> TI(tx,ty)>0;

    function moveX(dx){
        if (!dx) return;
        cat.x += dx;
        const dir = dx>0?1:-1;
        const xProbe = dir>0? cat.x+cat.w-1 : cat.x;
        const tx = Fl(xProbe / T);
        const y0 = Fl(cat.y / T), y1 = Fl((cat.y + cat.h - 1) / T);
        for (let ty=y0; ty<=y1; ty++){
            if (solid(tx,ty)){
                if (dir>0) cat.x = tx*T - cat.w;
                else       cat.x = (tx+1)*T;
                cat.vx = 0;
                break;
            }
        }
    }

    function moveY(dy){
        if (!dy) {
            // Standstill: set grounded based on tiles directly under the feet
            const yBelow = Fl((cat.y + cat.h) / T);
            const x0 = Fl(cat.x / T), x1 = Fl((cat.x + cat.w - 1) / T);
            let grounded = false;
            for (let tx=x0; tx<=x1; tx++){
                if (solid(tx, yBelow)) { grounded = true; break; }
            }
            cat.onGround = grounded;
            return;
        }
        // ---- normal vertical motion & collision ----
        cat.y += dy;
        const dir = dy>0?1:-1;
        const yProbe = dir>0? cat.y+cat.h-1 : cat.y;
        const ty = Fl(yProbe / T);
        const x0 = Fl(cat.x / T), x1 = Fl((cat.x + cat.w - 1) / T);
        for (let tx=x0; tx<=x1; tx++){
            if (solid(tx,ty)){
                if (dir>0){ // falling
                    cat.y = ty*T - cat.h;
                    cat.vy = 0;
                    cat.onGround = true;
                } else {    // head bump
                    cat.y = (ty+1)*T;
                    cat.vy = 0;
                }
                return;
            }
        }
        cat.onGround = false;
    }

    // ===== Sprite Animator =====
    const SPR_SCALE = 1; // visual scale
    const PREFIX = 'assets/';
    const ANIMS = {
        Idle:{file:PREFIX+'Cat-2-Idle.png',frames:10,fps:6},
        Walk:{file:PREFIX+'Cat-2-Walk.png',frames:8,fps:10},
        Run:{file:PREFIX+'Cat-2-Run.png',frames:8,fps:12},
        Meow:{file:PREFIX+'Cat-2-Meow.png',frames:4,fps:8},
        Laying:{file:PREFIX+'Cat-2-Laying.png',frames:8,fps:10},
        Stretching:{file:PREFIX+'Cat-2-Stretching.png',frames:13,fps:9},
    };

    // Preload
    const sheets = {};
    let assetsReady = false;
    (async function preload(){
        const loads = Object.entries(ANIMS).map(([k,v])=> new Promise(res=>{
            const img = new Image();
            img.onload = ()=>{ console.log('Loaded:', v.file, img.width+'x'+img.height); sheets[k]=img; res(); };
            img.onerror = (e)=>{ console.error('FAILED to load:', v.file, e); res(); };
            img.src = v.file;
        }));
        await Promise.all(loads);
        assetsReady = true;
    })();

    // Animation state machine
    let animName='Idle', animLock=0;
    let animFrame=0, animClock=0;   // current frame + time accumulator
    const ANIM_SPEED = 0.65;        // global slow-down (65% of listed fps)
    let moveState = 'Idle';
    const TH = {
        idleToWalk: 18,
        walkToIdle: 10,
        walkToRun: 140,
        runToWalk:  90
    };

    function startAnim(name, lockSec=0){
        if (animName!==name){
            animName = name;
            animFrame = 0;
            animClock = 0;
        }
        animLock = Math.max(animLock, lockSec||0);
    }

    function pickAnim(){
        if (animLock>0) return;

        if (!cat.onGround){
            const s = Math.abs(cat.vx);
            startAnim(s>120 ? 'Run' : (s>10 ? 'Walk' : 'Idle'));
            return;
        }

        const s = Math.abs(cat.vx);
        if (moveState==='Idle'){
            if (s > TH.idleToWalk) moveState = 'Walk';
        } else if (moveState==='Walk'){
            if (s > TH.walkToRun)      moveState = 'Run';
            else if (s < TH.walkToIdle) moveState = 'Idle';
        } else if (moveState==='Run'){
            if (s < TH.runToWalk) moveState = 'Walk';
        }
        startAnim(moveState);
    }

    // ===== Game clock =====
    let last = performance.now(), acc = 0, frame = 0;
    const DT = 1/60;
    let timeSec = 0; // for emitter flicker

    function update(dt){
        frame++;
        timeSec += dt;

        // Meow input → play Meow (brief lock)
        if (keys.M){
            startAnim('Meow', 0.35); // ~0.35s lock
            keys.M=0; // one-shot
        }

        // Timers
        animLock = Mx(0, animLock - dt);
        coyote = Mn(coyote + (cat.onGround? (COYOTE - coyote) : -dt), COYOTE);
        if (!cat.onGround) coyote = Mx(0, coyote - dt);
        jumpBuffer = Mx(0, jumpBuffer - dt);

        // Horizontal input
        const ax = (keys.R - keys.L) * ACC;
        cat.vx += ax * dt;
        // friction + deadzone
        if (!keys.L && !keys.R) cat.vx *= cat.onGround ? 0.85 : 0.98;
        if (Math.abs(cat.vx) < 6) cat.vx = 0;
        cat.vx = clamp(cat.vx, -MAX_VX, MAX_VX);
        if (Ab(cat.vx)>1) cat.dir = cat.vx>0 ? 1 : -1;

        // Jump if buffered and allowed (ground or within coyote)
        if (jumpBuffer > 0 && (cat.onGround || coyote>0)){
            cat.vy = -JUMP_V;
            jumpBuffer = 0; coyote = 0; cat.onGround = false;
        }

        // Gravity
        cat.vy = Mn(cat.vy + GRAV*dt, MAX_FALL);

        // Integrate & collide (separate axes)
        moveX(cat.vx * dt);
        moveY(cat.vy * dt);

        // Keep within world bounds horizontally
        cat.x = clamp(cat.x, 0, world.w*T - cat.w);

        // Choose animation based on current state
        pickAnim();
        // Advance current animation frame
        const a = ANIMS[animName];
        if (a) {
            animClock += dt * (a.fps || 10) * ANIM_SPEED;
            while (animClock >= 1) {
                animClock -= 1;
                animFrame = (animFrame + 1) % a.frames;
            }
        }
    }

    function render(){
        // Background
        ctx.clearRect(0,0,innerWidth,innerHeight);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,innerWidth,innerHeight);

        // Stars
        const t = performance.now()*0.001;
        for (let i=0;i<stars.length;i++){
            const st = stars[i];
            const tw = .7 + .6*Sn(t*2.2 + st.p);
            const r  = st.s * tw;
            ctx.fillStyle = '#888';
            ctx.fillRect(st.x - r/2, st.y - r/2, r, r);
        }

        // Rooftops
        if (world){
            const {w,h,tiles} = world;
            ctx.fillStyle = '#111';
            for (let x=0; x<w; x++){
                let y=0, found=false;
                for (; y<h; y++){ if (tiles[x + y*w]) { found=true; break; } }
                if (found){
                    const ypx = y*T;
                    ctx.fillRect(x*T, ypx, T, h*T - ypx);
                }
            }
            ctx.fillStyle = '#222';
            for (let x=0; x<w; x++){
                for (let y=0; y<h; y++){
                    if (tiles[x + y*w] === 1){ ctx.fillRect(x*T, y*T, T, 2); break; }
                }
            }
        }

        // --- Step 5: draw light cones (debug visualization) ---
        drawEmitters();

        // Cat
        drawCat();

        // Tiny HUD/help
        ctx.fillStyle = '#444';
        ctx.fillRect(12, 12, 80, 6 + 4*Sn(t*2));
        ctx.fillStyle = '#777';
        ctx.font = '10px monospace';
        ctx.fillText('← → move  ↑/Z/Space jump  X meow', 12, 40);
    }

    function drawEmitters(){
        const es = world.emitters;
        for (let i=0;i<es.length;i++){
            const e = es[i];

            // Scan around center (no 360° spin)
            const a0   = e.center + e.amp * Sn(timeSec * e.omega + e.phase);
            const half = e.spread * 0.5;
            const a1 = a0 - half, a2 = a0 + half;

            const len = e.len * (1 + 0.18 * Sn(timeSec * e.flicker + e.phase));
            const x1 = e.x + Cs(a1)*len, y1 = e.y + Sn(a1)*len;
            const x2 = e.x + Cs(a2)*len, y2 = e.y + Sn(a2)*len;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.beginPath();
            ctx.moveTo(e.x, e.y);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255,255,210,0.22)'; // a bit brighter
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255,255,230,0.38)';
            ctx.stroke();
            ctx.restore();

            // window dot
            ctx.fillStyle = '#0ff';
            ctx.fillRect(e.x-2, e.y-2, 4, 4);
        }
    }




    function drawCat(){
        const a = ANIMS[animName];
        const img = sheets[animName];

        // Common anchors
        const drawX = (cat.x + cat.w/2)|0;

        // Placeholder while assets load — uses SAME alignment logic
        if (!assetsReady || !img){
            const fw = 50, fh = 50;                      // your frames are 50x50
            const w  = fw * SPR_SCALE, h = fh * SPR_SCALE;
            const drawY = ((cat.y + cat.h) - h + SPRITE_FOOT_OFFSET + SPRITE_Y_OFFSET)|0;
            const dir = cat.dir < 0 ? -1 : 1;
            const oX  = (SPRITE_X_OFFSET * SPR_SCALE) * dir;

            if (DEBUG_SPRITE_ALIGN){
                ctx.strokeStyle = '#0f0';
                ctx.strokeRect(cat.x|0, cat.y|0, cat.w|0, cat.h|0); // physics box
            }

            ctx.save();
            ctx.translate(drawX, drawY);
            if (dir < 0) ctx.scale(-1, 1);               // flip around anchor
            ctx.fillStyle = '#e6e6e6';
            ctx.fillRect(-w/2 + oX, 0, w, h);
            if (DEBUG_SPRITE_ALIGN){
                ctx.strokeStyle = '#f0f';
                ctx.strokeRect(-w/2 + oX, 0, w, h);        // sprite rect
            }
            ctx.restore();
            return;
        }

        // Real sprite
        const f = animFrame | 0;
        const fw  = (img.width / a.frames) | 0;
        const fh  = img.height | 0;
        const w   = fw * SPR_SCALE, h = fh * SPR_SCALE;
        const sx  = f * fw, sy = 0;

        const drawY = ((cat.y + cat.h) - h + SPRITE_FOOT_OFFSET + SPRITE_Y_OFFSET)|0;
        const dir   = cat.dir < 0 ? -1 : 1;
        const oX    = (SPRITE_X_OFFSET * SPR_SCALE) * dir;

        if (DEBUG_SPRITE_ALIGN){
            ctx.strokeStyle = '#0f0';
            ctx.strokeRect(cat.x|0, cat.y|0, cat.w|0, cat.h|0);   // physics box
        }

        ctx.save();
        ctx.translate(drawX, drawY);
        if (dir < 0) ctx.scale(-1, 1);               // flip around anchor (no translate(w,0))
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, sx, sy, fw, fh, -w/2 + oX, 0, w, h);
        if (DEBUG_SPRITE_ALIGN){
            ctx.strokeStyle = '#f0f';
            ctx.strokeRect(-w/2 + oX, 0, w, h);        // sprite rect
        }
        ctx.restore();
    }

    function loop(now){
        const dt = Mn(0.05, (now - last) / 1000);
        last = now; acc += dt;
        while (acc >= DT) { update(DT); acc -= DT; }
        render();
        requestAnimationFrame(loop);
    }

    // boot
    fit();
    requestAnimationFrame(loop);
</script>
</html>
